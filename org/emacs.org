#+OPTIONS: "\n:t"

* C-h r 自带manual
* shell
   emacs支持shell模式有
   shell term ansi-term muti-term eshell
   muti-term可以很容易支持开多个终端
   
   shell-command执行一条命令时很方便 Alt+!
   省去了上下文跳转，思路更加流畅

   在multi-term下使用vi编辑文件时，无法使用esc退出编辑状态
   可以使用C-c C-c term-interrupt-subjob
 
   eshell 是全用elisp实现的，直接直接执行elisp
   (+ 1 1) 输出2
   (find-file /tmp)
   或者file-file /tmp
   如果想打开多个eshell，可以在eshell中执行eshell N （其中N为数字）

   在emacs中，使用ansi-term muti-term登录到其它机器上，
   运行top命令时，会出现'eterm-color'  Unknown terminal type
   -bash-3.00$ echo $TERM   
   'eterm-color'
   运行一下这句，就ok了
   -bash-3.00$ export TERM=eterm
  
* 计算器
   c-x * q   quick-calc
   c-x * c   calc

   其中quick-calc，可以直接输入代数表达式。
   而calc默认的是逆波兰序，例如1+1, 应以此输入1 1 +
   但是可以输入 ' 后也可以直接输入代数表达式
   
   calc进制转换
   d2 d8 d0 d6 以此转换为2、8、10、16进制

* 管理buffers
   emacs强悍一点是buffer狂多。
   默认的list-buffers不好用。
   如何快捷简单的管理buffers呢
   使用ibuffer就是一个很好的选择
   例如/ m 使用模式过滤
      / f  使用名字的正则过滤
      等等
* register
利用 register 保存光标位置.
- C-x r <SPC>; , 会提示输入一个字母, 表示寄存器的名字. 这样这个寄存器就记录了但前的光标位置.
- C-x r j 然后输入寄存器的名字,就可以跳转到原来保存的位置了.
利用 register 保存窗口布局.
C-x r w 可以记录当前的窗口布局,包括光标位置. 同样 C-x r j 就可以恢复窗口布局.
利用 register 保存文字.
C-x r s 可以在寄存器中copy 一段文字.
C-x r i 可以恢复这个文字.

* linux: Unknown terminal type
   在emacs中，使用ansi-term muti-term登录到其它机器上，
   运行top命令时，会出现'eterm-color'  Unknown terminal type
   -bash-3.00$ echo $TERM   
   'eterm-color'
   运行一下这句，就ok了
   -bash-3.00$ export TERM=vt100

* ido烦人一点
   当我要新建一个文件时，如果当前目录下有类似文件名的文件，
   ido总打开这个文件，让不能创建文件。
   这时候你需要再C-f (It should kick you out of ido mode into "normal" find file mode)
   C-x C-f C-f
* 光标移动
   最好的移动是 C-s 和 C-r
* 键盘宏
-  开始 C-x (
-  结束 C-x )
-  播放 C-x e
可以利用重复动作执行10次： C-u 10 C-x e
也可以对宏进行命令并保存在文本中，可以下次使用
M-x name-last-kbd-macro
输入宏的名字
M-x inster-kbd-macro
输入宏的名字，就可以把宏插入到当前buffer中

* kill buffer
   C-x k bufname <RET>
   Kill buffer bufname (kill-buffer). 
   M-x kill-some-buffers
   Offer to kill each buffer, one by one. 
   M-x kill-matching-buffers
   Offer to kill all buffers matching a regular expression.

* buffer切换
  我之前buffer之前的切换，几乎全用tabbar，效率低。
  现在采用helm、history stack 和 register方式，实现快速跳转。
* 版本控制
  emacs 统一的前端VC，
  无论底层使用CVS、SVN操作都一样。
  常用的功能：
  提交 C-x v v
* 设置emacs字体

  通过options菜单选择字体，满意后
  M-x ielm RET 
  执行 (frame-parameter nil 'font) RET
  获取配置的字符串例如"-outline-Courier New-normal-r-normal-normal-16-120-96-96-c-*-iso8859-1"

  把如下形式的代码贴入.emacs，即可。

#+begin_src lisp
(set-default-font "-outline-Courier New-normal-r-normal-normal-16-120-96-96-c-*-iso8859-1")
(add-to-list 'default-frame-alist '(font . "-outline-Courier New-normal-r-normal-normal-16-120-96-96-c-*-iso8859-1"))  
#+end_src

* 交换Ctrl和Alt
1.在linux下:
在~目录下建立名为“.Xmodmap”的文件，
（x一定要大写）
内容如下：
#+begin_example
remove mod1 = Alt_L
remove control = Control_L
add control = Alt_L
add mod1 = Control_L

remove mod1 = Alt_R
remove control = Control_R
add control = Alt_R
add mod1 = Control_R
#+end_example
2.在windows下:
使用KeyTweak之类的软件进行设置.

* 不用shift输入perl $
  最近常写perl，发现输入$等特别累。于是就产生这个想法。
  使用命令：xmodmap -pke 
  显示出：
#+begin_example
....
keycode  10 = 1 exclam 1 exclam
keycode  11 = 2 at 2 at
keycode  12 = 3 numbersign 3 numbersign
keycode  13 = 4 dollar 4 dollar
keycode  14 = 5 percent 5 percent
keycode  15 = 6 asciicircum 6 asciicircum
keycode  16 = 7 ampersand 7 ampersand
keycode  17 = 8 asterisk 8 asterisk
keycode  18 = 9 parenleft 9 parenleft
keycode  19 = 0 parenright 0 parenright
....略
#+end_example
找到我们关心的数字键。
例如数字键“1"
运行命令：
xmodmap -e "keycode  10 = exclam 1 exclam 1"
然后测试发现不用shift可以直接输出#号。

测试感觉很好，但是问题也出来了。
输入法中，选择时输入数字还得shift，累了。

还得采用emacs内部键绑定。

* 把自己经常重复的编辑动作写成elisp函数
  今天在网上看到几个函数，例如格式化整个buffer等，
  我经常全选整个缓存区，然后在ctrl-alt-\，很麻烦

* org-mode 插入时间戳（记日记）
  C-c !
  用于记日记

* emacs + fcitx 不能输入汉字问题
 增加一条配置命令到.emacs把C-SPC组合键屏蔽掉。
 (global-set-key (kbd "C-SPC") 'nil) 
 做个shell文件放在桌面上。
#!/bin/sh
 export LC_CTYPE=zh_CN.UTF-8
 emacs

* emacs 换行符 windows格式转成UNIX格式
#+begin_example
在曙光时，做项目需要在windows上使用putty通过SSH登录到LINUX上写代码，
很不舒服，就是使用samba建立与windows的目录共享。
这样直接可以在windows上操作LINUX上的代码了。
但是问题就来了。windows上换行符与LINUX不同，在windows编辑的文件，在LINUX编译不过。
想了一个简单的办法
#+end_example
#+begin_src lisp
(global-set-key (kbd "C-x C-s") 
  (lambda()
    (interactive)
   (set-buffer-file-coding-system 'unix 't)

    (save-buffer)))
#+end_src
#+begin_example
在保持代码时，自动设置为unix格式。问题就解决了。^_^
(set-buffer-file-coding-system 'unix 't) 关键的一句啊！
#+end_example
* delete line back
  C-0 C-k
* 管理项目
   在项目内，快速打开指定文件，使用find-tag，我绑定到M-.
* etags
  find . -name "*.[ch]" -o -name "*.cpp" - print | etags - 
  find . -name "*.[chCH]" -print | etags -
  上述命令可以在当前目录查找所有的.h和.cpp文件并把它们的摘要提取出来做成TAGS文件，具体的etags的用法可以看一下etags的 manual。
  创建好tag表后，告知emacs。
  M-x visit-tags-table

  如果要emacs自动读取某个TAGS文件，可以在~/.emacs文件中加入一行,设置tags-file-name变量
  (setq tags-file-name "path/TAGS")

  如果要一次查找多个TAGS文件，可以设置tags-table-list变量
  (setq tags-table-list '("path1/TAGS" "path2/TAGS" "path3/TAGS"))
  另外，对于较大又不是经常使用的TAGS，尽量放到该list的后面，避免不必要的打开

  常用的热键：
  M-. 查找一个tag，比如函数定义类型定义等。
  C-u M-. 查找下一个tag的位置
  M-*/M-, 回到上一次运行M-.前的光标位置。
  M-TAB 自动补齐函数名。 

* 常用基本功能

** 移动光标
键绑定	使用说明
C-f	向右移动一个字符 forward
C-b	向左移动一个字符 backward
C-n	光标移到下一行 next
C-p	光标移到上一行 previous
C-a	光标移到行首 ahead
C-e	光标移到行尾 end
C-down	移到后一段落开始
C-up	移到前一段落开始

 C-f, C-b: 以字符为单位移动。
 M-f, M-b: 以单词为单位移动。
 C-a, C-e: 移动到行首，行末。
 M-m: 移动到第一个非空格字符。(back-to-indentation)
 M-a, M-e: 移动到句子头，句子尾。
 M-{, M-}: 移动到段落头，段落尾。
 C-v, M-v: 翻页。 
  M-<, M->: 到文件头和文件尾。 C-Home C-End
   beginning-of-buffer end-of-buffer
 C-M-a   到 defun 头 移到到函数头
 C-M-e   到 defun 尾
   beginning-of-defun end-of-defun
   我绑定在C-z a 和 C-z e上
C-M-f   到下一个同级语法结构 forward-sexp
C-M-b   到上一个同级语法结构 backward-sexp
C-M-d: 进入到下一级结构里。
C-M-u: 进入到上一级结构里。 

C-x r m	标记当前位置为书签
C-x r b	跳到某个书签位置
C-x r r	复制一块矩形区域，并注册到某个 register
C-x r i	插入某个 register 中的矩形内容
C-x r c	清除某一块矩形，但右侧内容不会左移，被清除的内容不会进入kill-ring

C-x C-q	改变 buffer 的只读状态

C-x <chr>

C-x 后跟字符扩展
窗口
键绑定	使用说明
C-x o	在已打开的窗口间切换
C-x 1	关闭除了光标所在的其他所有窗口
C-x 2	水平新建一个窗口 window
C-x 3	垂直新建一个窗口 window
C-x d	Emace 的 dired 模式
** 缓冲区
键绑定	使用说明
C-x s	保存所有未存盘的buffer
C-x k	kill关闭当前的buffer
C-x b <buffer_name>	快速打开某个缓冲区，可使用 tab 自动完成
C-x i	将其他文件插入当前 buffer
C-x 4 b	在别的 window 中打开另外一个 buffer
C-x 5 b	在别的 frame 中打开另外一个 buffer
C-x 4 .	在新 window 中 find-tag
C-x 5 .	在新 frame 中 find-tag
C-x h	全选

注： 当 C-x b ，你输入的 buffer 名不存在时，Emacs 会新建一个 buffer，名字就是你刚才输入的名字。
键绑定	使用说明
C-x RET f coding	Use coding system coding for saving or revisiting the visited file in the current buffer.
C-x RET c coding	Specify coding system coding for the immediately following command.
C-x RET r coding	换个编码浏览当前buffer中的内容
C-x RET l coding	换个 language environment

Link: M-x recode-region
其他
键绑定	使用说明
C-x u	撤销之前的操作
C-x [	到前一个 ^L 处去
C-x ]	到后一个 ^L 处去
C-x r m	标记当前位置为书签
C-x r b	跳到某个书签位置
C-x r SPC	设定 register
C-X r j	跳到某个 register
C-x (	开始 macro 记录
C-x )	结束 macro 记录
C-x n n	仅显示被 mark 的内容，其他暂时隐藏
C-x n w	恢复 C-x n n 的操作
C-x =	查看光标所在字元的信息
C-x r k	将此块矩形区域内的内容删除，可供C-x r y 使用
C-x r y	将删除的矩形区域内容插入某处
C-x r t	将矩形区域替换成别的字符
C-x r d	仅删除矩形内容，不可供 C-x r y 使用
C-x r o	插入一块大小与选中矩形区域相同的空白的矩形区域
C-x r r	复制一块矩形区域，并注册到某个 register
C-x r i	插入某个 register 中的矩形内容
C-x r c	清除某一块矩形，但右侧内容不会左移，被清除的内容不会进入kill-ring
C-x 8 RET	ucs-insert 插入unicode字符

注： 建立^L 标记按 C-q C-l 注： 类似 C-x r t 的还有一个命令 M-x string-insert-rectangle ，它不会把选中的矩形区域全部替换，而是在之前添加要插入的字符串。
C-x C-<chr>

C-x 后跟另一个 C-? 键绑定
文件/缓冲区
键绑定	使用说明
C-x C-f	打开 本地/远程 文件
C-x 4 C-f	在新窗格(windows)中打开文件
C-x 5 C-f	在新出口(frame)中打开文件
C-x C-r	以只读方式打开文件
C-x C-s	保存当前buffer
C-x C-w	另存为当前buffer
C-x C-v	在当前窗口打开另外一个文件，并杀掉当前窗口中的 buffer
C-x C-c	退出 Emacs
C-x C-b	浏览所有的缓冲区
C-x C-q	改变 buffer 的只读状态
C-x C-o	删除空白行
C-x 4 C-o	再打开了诸如 C-h k 或 shell-mode 后，回到之前的buffer
C-x C-d	列出某个目录下的文件
C-x C-<right>	切到下一个缓冲区
C-x C-<left>	切到上一个缓冲区
C-x C-e	在某一行 Lisp 语句结尾按此键绑定，那么这句 Lisp 就对 Emacs 有效了

注1： C-x C-f 打开远程文件时，格式应该为：

Find file: /user@ftp.xxx.com:/home/user/xx
其他
键绑定	使用说明
C-x C-x	交换一个 region 的 point 和 mark 位置，回到初始 mark 的地方
C-x C-p	切换到前一个 buffer (yic-buffer)
C-x C-n	切换到后一个 buffer (yic-buffer)
C-x C-t	对调两行的位置
C-x C-=	增大字体
C-x C–	减小字体
C-h <chr>
帮助
键绑定	使用说明
C-h t	在线的 Emacs 的 tutorial，帮助你快速上手Emacs
C-h r	Emacs 的 Manual
C-h i	Info 手册，第一次查看可按 ?
C-h c	给出一个简短的键绑定/菜单项的说明
C-h k	比 C-h c 更加详细
C-h K	定位到 Info 文档中描述该命令的位置
C-h m	对当前主模式的描述，其中包括该模式的键绑定
C-h f	查询可用的命令，可使用 tab 自动完成
C-h a	查找命令中的关键字，可使用多个关键字或正则表达式来匹配。
C-h b	列出所有的键绑定
C-h d command-name	查找文档中的关键字，可使用多个关键字或者正则表达式匹配
C-h C	对某个编码系统的描述
C-h l	最近一百个按键
C-h v	查看 Emacs 中的所有变量，可用 tab 自动完成
C-h w	查看 function 的键绑定和在哪个菜单中
C-h ?	列出所有可用的 C-h 相关的键绑定
C-h C-f	查看一个函数的 info
C-h C-h	同 C-h ?

注： 除了C-h ? 外，其余在输入键绑定后，要继续输入键绑定或者字符串。 Note: 试试C-x r C-h，对，他会列出所有以C-x r 开头的键绑定！
C-c

C-c 通常用在某个特定 mode 下，比如 org-mode 中的 C-c C-e h(输出 html 格式)。
键绑定	使用说明
C-c C-h	查看当前主模式下的所有键绑定
C-u
键绑定	使用说明
C-u <num> C-<chr>	重复执行 <num> 次 C-<chr>
C-u <num> C-v/M-v	将屏幕向下/上滚动 <num> 行
C-u 0 C-l	使光标所在行显示在屏幕最上面一行，同 M-0 C-l
C-u <num> <chr>	输入 <num> 个 <chr> 字符
C-u M-.	继续查找其他文件（或当前文件）中相同名称的定义
C-u M-^	合并本行和下一行
C-u C-x =	查看光标下的字符信息

Tip: :C-u 5 kbindings => C-5 kbindings :C-u 10 kbindings => C-1 C-0 kbindings
C-<chr> (<num> C-<chr>)

** 删除(复制)/撤销
键绑定	使用说明
C-d	删除光标后的一个字符
C-k	删除光标至行尾的所有字符，是 kill
C-@ … C-w	删除 C-@ 至 C-w 间的字符，分别在不同的光标处按这两个键绑定，属于 kill
C-@ … M-w	同上，只是不删除而是复制字符
C-y	在光标处插入被 kill 的字符，本文档中注有 kill 的键绑定
C-/	撤销
C-_	撤销

** 搜索
键绑定	使用说明
C-s	渐进式向后搜索
C-r	渐进式向前搜索
其它
键绑定	使用说明
C-t	互换两个字符
C-z	暂时挂起 Emacs，调回用 fg
C-v	向下翻页
C-l	光标所在行显示在屏幕中央
C-g	取消数字参数和只输入到一半的命令，中断搜索
C-[	可用来代替 Meta 或 ESC
C-q C-l	建立一个 page 标记 ^L
C-]	退出 query-replace 的递归编辑
C-q	插入控制符号，后面跟相应的控制符键绑定
C-\	调出 Emacs 内置的输入法
C-m	等于回车
** M-x <command-name>

M-x 后跟命令扩展
命令
命令名称	使用说明
shell	打开一个 shell，就是shell-mode
recover-file<RET>	恢复当前 buffer，如果同目录下有#buffer_name#文件的话
revert-buffer	重新载入文件，之前所有操作无效
load-file	不重启 Emacs，重新载入并更新配置文件
byte-compile-file	预编译 .el 文件，生成 .elc 文件，执行速度更快
display-time	在 minibuffer 显示时间等信息
delete-matching-lines	删除满足正则条件的行
delete-not-matching-lines	删除不满足正则条件的行
count-lines-{region/page}	计算行数
desektop-clear	kill 掉所有默认内部 buffer(Messsage等) 之外的 buffer
pwd	查看所打开文件所在的路径
mark-page	mark 一块 page (L)
flush-lines	删除匹配正则表达式的行
keep-lines	保留匹配正则表达式的行
recode-region	Convert a region that was decoded using coding system wrong, decoding it using coding system right instead.
apropos	正则查找所有命令、函数、变量
delete-trailing-whitespace	删除所有行末的空白字符
describe-coding-system	描述当前buffer在Emacs 内部采用的哪种编码，可用 C-x RET r 改变
delete-*	很多有用的删除命令，比如删除空行
butterfly	Wow
list-input-methods	
list-char*	列出编码有关的信息
ucs-insert	插入unicode字符
proced	查看进程
epa-*	EasyPG Assistant (epa) is interface to GNU Privacy Guard (gpg).
** 模式
键绑定	使用说明
org-mode	org模式
auto-fill-mode	自动截行模式
dired	Emacs 的 dired 模式
flyspell-mode	即时拼写检查
mouse-avoidance-mode	鼠标指针躲避模式，自动远离当前光标，很有意思
resize-minubuffer-mode	顾名思义，超过一行信息时自动调整 minibuffer 宽度
menu-bar-mode	关闭/打开菜单栏
woman	查看 man 文档
tags-search	多个文件中查找字符串
tags-query-replace	多个文件中进行 M-% 操作
tags-apropos	查找满足关键字的定义，并列表
follow-mode	分几页窗口连续的显示内容，同步翻页
outline[-minor]-mode	在不同标题间跳转，隐藏/显示
wdired-change-to-wdired-mode	在 dired 模式下直接对文件名进行编辑操作
longlines-mode	类似 auto-fill，但是只是虚拟，不会对原文件进行修改
transient-mark-mode	选中文本加亮
delete-selection-mode	按DEL删除选中的文字
visual-mode	???
linum-mode	行号
whitespace-mode	显示空白、TAB和空白行
游戏
键绑定	使用说明
tetris	俄罗斯方块
gomoku	五子棋
doctor	心理医生
snake	贪吃蛇

用法： 输入 M-x 后，再输入上述某个命令名称。
M-<chr>
移动光标
键绑定	使用说明
M-f	向右移动一个词 forward
M-b	向左移到一个词 backward
M-a	光标移到句首
M-e	光标移到句尾
M->	光标移到所有文字的最末
M-<	光标移到所有文字的最开头
M-g	到某一行去(GNU Emacs 默认未绑定)
M-{	到前一段落
M-}	到后一段落

删除(复制)
键绑定	使用说明
M-<backspace>	删除光标前的一个词
M-d	删除光标后的一个词
M-k	删除光标到句尾的所有字符，以中英文句号为标志
M-y	在按了 C-y 后，每按一次此键绑定，则从 kill rings 中选择之前被 kill 的字符插入
M-\	删除 point 附近不必要的空白和 tab，通常是行末
M-spc	跟 M-\ 类似，只是还会保留一个空格
M-^	删除缩进，但常用于合并行(C-u )
搜索/替换
键绑定	使用说明
M-%	每次找到匹配的待替换字符串后询问你该如何操作(y 替换/n 乎略/! 往后全部替换)
	
其它
键绑定	使用说明
M-!	打开 shell-command mode
M-pipe	将 mark 的 region 作为 stdout 给某个系统命令
M-v	向上翻页
M-t	交换两个单词的前后顺序
M-.	寻找 TAGS 文件或者其中的定义
M-n	在 minibuffer 中向后翻看历史记录
M-p	在 minibuffer 中向前翻看历史记录
M-$	ispell-word 拼写检查光标前的一个词
M-c	将光标开始以后的单词做首字母小写处理
M-l	同上，只是做首字母大写处理
M-u	将光标开始后的单词做全部大写处理
M-/	从整个当前 buffer 中自动完成单词
M-q	自动调整列宽
M-h	mark 这个段落
M-:	执行 elisp 表达式
M-=	得知某选定区域的信息

注：

M-pipe 就是 M-|

C-u M-! 在 point 处插入命令执行结果;

C-u M-| 用命令执行结果替换 region 的内容;
M-<chr> C-<chr>
键绑定	使用说明
M-0 C-l	使光标所在行显示在屏幕最上面一行，同 C-u 0 C-l
M– C-l	使光标所在行显示在屏幕最下面一行
M-<num> C-<chr>	重复执行<num>次 C-<chr>
C-M-<chr>
键绑定	使用说明
C-M-v	对当前光标外，新打开的窗口进行 C-v 向下翻页
C-M-S-v	对当前光标外，新打开的窗口进行 M-v 向上翻页
C-M-s	正则表达式搜索（forward）
C-M-r	正则表达式搜索（backware）
C-M-%	正则表达式替换
C-M-@	快速 mark 一个 sexp
C-M-h	快速 mark 一个 函数
C-M-\	对上面两个命令 mark 的 region 自动调整缩进
C-M-q	对一个 sexp 不 makr 而直接自动调整缩进
C-S-<chr>
键绑定	使用说明
C-S-backspace	删除一行（无论光标在哪儿）
Mouse

有些时候鼠标操作也很高效。 说明： B1 是鼠标左键单击一下; B2 是鼠标中键单击一下; B3 是鼠标右键单击一下。
键绑定	使用说明
B1	设置 point
B1-B1	选中一个单词并放入 kill-ring
B1-B1-B1	选中一行内容并放入 kill-ring
B2	在鼠标中键单击处插入最近一次被 kill 的内容，并把光标(point)定位到插入内容的末
B3	高亮从 point 到当前鼠标右击处的 region，并放入 kill-ring
B3-B3	删除从 point 到当前鼠标右击两次处的 region，并放入 kill-ring
org-mode
键绑定	使用说明
C-c C-e h	生成 html 文档
C-c C-e t	插入输出选项
C-c C-l	重新编辑链接
C-c C-o	打开链接
C-c C-t	改变 TODO 项目的状态
C-c C-a	显示全部项目内容
M-S-<RET>	插入一个新的 TODO 项目
M-<RET>	插入一个同级别的标题
TAB	光标移动到某个级别的星号上，它会不断在概要、全文中切换
S-tab	不在表格内时是查看整个项目的提纲或全文，否则是自动调整表格宽度
M-<left>	使 item 级别大一级(在 item 的名称上按)
M-<right>	使 item 级别小一级
M-<up>	使 item 上移一层
M-<down>	使 item 下移一层

* gpg配合emacs加密文件 
   我使用emacs org-mode记日记,然后通过svn到google code上,
   所以日记最好加一下密毕竟是隐私的东西.
   使用easygpg(emacs自带的lisp)
   在.emacs加入:
    (require 'epa-file)
    (epa-file-enable)
    ;;使用对称加密
    (setq epa-file-encrypt-to nil)
    ;;保存一个session的密码,不然需要总输入密码
    ;; save the password
    (setq epa-file-cache-passphrase-for-symmetric-encryption t)
    ;; auto-save
    (setq epa-file-inhibit-auto-save nil)

    这样遇到.gpg结尾的文件,emacs可以自动调用gpg解密文件,保存时自动加密阿文件了.
* 在org-mode搜索
   org-occur
   org-occur-in-agenda-files
* 编辑远程文件
   使用tramp
   配置文件
   (require 'tramp)
   (setq tramp-default-method "ssh")
   然后使用 /usr@machine:/path/to.file 的语法来访问远程文件。
   tramp与ido-mode冲突时，使用前先关闭ido-mode

   C-x C-f /ssh:root@10.0.64.18
* c/c++几个操作
M-a        移动到当前语句的开始
M-e        移动到当前语句的末尾

C-M-a      移动到当前函数的开始
C-M-e      移动到当前函数的结尾

M-q        若光标在注释文本中间，则进行段落重排，保留缩进和前导字符

C-M-h      把光标放在当前函数开头，把文本块标记放在函数结尾， 即把函数整个选作为一个文本块。

C-c C-q    对整个函数进行缩进
C-x h      选定整个buffer，  然后C-M-\可以对代码进行重新排版

C-c C-u    移动到当前预处理条件的开始位置
C-c C-p    移动到上一个预处理条件
C-c C-n    移动到下一个预处理条件

M-;        对当前行进行注释
C-x C-x    快速返回移动前的光标位置

C-c C-c    对一块代码进行注释；取消注释用命令 uncomment-region

C-c C-\       将区域中的每一行结尾都加入一个'\'字符

* 对齐 align-regexp
   C-M-\，对齐一般都能满足需要
   有时候需要按一行中的某些字符对齐，比如一些变态的语言或者编程规范规定赋值语句需要按”=”对齐，那怎么办?
   比如如下代码:
#+BEGIN_SRC c
int var = 2;
int variable_is_kinda_long = 3;
int var_is_less_long = 4;
#+END_SRC

   需要按 = 对齐，选中执行M-x align-regexp, 然后 regexp 填 =，结果如下:
#+BEGIN_SRC c
int var                    = 2;
int variable_is_kinda_long = 3;
int var_is_less_long       = 4;
#+END_SRC

* occur
  输出 buffer 中符合正则表达式的所有行，在查找替换时，或者需要重构代码时，事先用 occur 来验证下构造的正则表达式的效果，可以避免一时自信或者冲动毁了先前的工作.
* multi-occur-in-matching-buffers
可以对所有打开的 buffer 进行 regex search。
* follow-mode
  现在流行的是宽屏，宽度不是问题，因此 Emacs C-x 3 用的很多，但很多长的文档，要翻好多页，小拇指真疼。 
  竖分屏后执行 follow-mode 后，所有 buffer 显示同一文件的不同部分，可视范围翻倍，甚至数倍，这要看你的屏幕有多宽了。

* 搜索
  M-x rgrep
  在emacs使用find 与 grep，
  岂一个快字了得！
  快速遍历查找！
** emacs 目录搜索
利用 Emacs 本身的搜索功能进行搜索
在 agenda 里用 M-x org-agenda RET s 进行搜索；
当然，也可以直接用 Org 的 occur-tree 功能；
如果你想使用原生态的 Emacs 搜索功能，可以进入 dired 模式到你待搜索的目录里，用命令 M-x grep-find RET 进行本地全文搜索。

* dired-mark-files-regexp, dired-do-rename-regexp and dired-do-shell-command
* shell term上一条命令
#+begin_example
   在终端中经常使用历史中上一条命令，
   使用上下方向键，
   在emacs的终端，再使用方向键优点傻
   上一条：M-p
   下一条：M-n
#+end_example
* mew 显示附件中doc文件
   安装wvHtml
   sudo yum wv
   然后就可以了
* 自动检测文件编码，防止乱码
  ;; auto detect unicode
#+begin_src lisp
  (require 'unicad)
#+end_src
* 画框图
  artist-mode
  按鼠标中键，在弹出的菜单中选择图形
* Ctrl+Space
  在fedora上ctrl+space被ibus占用了。运行ibus-setup修改其设置
